from csv import DictReader
from rdflib import Graph, URIRef, Literal, Namespace
from rdflib import RDF, RDFS, OWL, SDO, SKOS, DCTERMS
from re import split
from warnings import warn
from otsrdflib import OrderedTurtleSerializer
from urllib.parse import quote_plus
from ._version import __version__ as version
from .utils import toLowerCamelCase
from .consts import (
    known_fields,
    types_map,
    relationships_map,
    splitters,
    serialization_order,
)


class tvd2rdfConverter:
    """Class to read a csv file with certain column headings defining an RDF vocabulary, convert it to an RDF graph and outputas RDF file."""

    def __init__(self):
        self.vocab_rdf = Graph()
        self.namespaces = dict()

    def add_namespace(self, prefix, uri):
        if (type(prefix) == str) and (type(uri) == str):
            if (len(prefix) == 0) or prefix == ":":
                prefix = "default"
            elif (prefix[-1]) == ":":
                prefix = prefix[:-1]
            else:
                prefix = prefix
            self.namespaces[prefix] = uri
        else:
            msg = "Both prefix and URI must be strings."
            raise TypeError(msg)
        return

    def read_csv(self, fname):
        with open(fname, "r") as csv_file:
            csv_reader = DictReader(csv_file)
            self.check_keys(csv_reader.fieldnames)
            for row in csv_reader:
                try:
                    self.convert_row(row)
                except ValueError as e:
                    msg = f"Cannot convert row {row}."
                    print(msg)
                    print(e)
                    warn(msg)
        return

    def read_namespaces(self, fname):
        """Load namespaces from a (csv) file."""
        with open(fname, "r") as csv_file:
            csvReader = DictReader(csv_file)
            for row in csvReader:
                if row["prefix"] and row["URI"]:
                    self.add_namespace(row["prefix"], row["URI"])
                elif row["URI"]:
                    self.add_namespace("", row["URI"])
                else:  # pass rows with missing data
                    pass

    def write_out(self, fn: str = "", fmt: str = ""):
        """Write the vocabulary terms definition file."""
        vg = self.vocab_rdf  # vocab graph
        if fmt == "":
            fmt = "turtle"
        if fmt in ["turtle", "n3", "nquads", "longturtle", "trig", "nt"]:
            aknow_str = f"# RDF generated by TVD2RDF Converter v{version}."
        elif fmt in ["xml", "pretty-xml", "trix"]:
            aknow_str = f"<!--RDF generated by TVD2RDF Converter v{version}.-->"
        else:
            aknow_str = ""
        if fn:  # output to file
            try:
                f = open(fn, "w")
            except Exception as e:
                print(f"Could not open file {fn} for writing.")
                raise e
            f.write(aknow_str)
            f.write("\n")
            f.close()
            if fmt == "turtle":  # Ordered serializaion...
                serializer = OrderedTurtleSerializer(vg)
                serializer.class_order = serialization_order
                with open(fn, "ab") as f:
                    serializer.serialize(f)
            else:
                with open(fn, "a") as f:
                    f.write(vg.serialize(format=fmt))
        else:  # output to terminal
            print("\n", aknow_str)
            print(vg.serialize(format=fmt))
            print("\n\n")

    def check_keys(self, fields):
        lower_fields = [f.lower() for f in fields]
        if ("uri" in lower_fields) and ("type" in lower_fields):
            pass
        else:
            msg = f"Must have columns for Type and URI in the input csv."
            raise ValueError(msg)
            return False
        for f in fields:
            field = toLowerCamelCase(f)
            if field in known_fields:
                pass
            else:
                msg = f"Cannot convert column {f} to RDF term."
                print(field)
                print(msg)
                warn(msg, stacklevel=2)
                return False
        return True

    def convert_row(self, row: dict):
        vg = self.vocab_rdf
        r = dict()
        for key, val in row.items():
            new_key = toLowerCamelCase(key)
            r[new_key] = val
        try:
            term = self._process_term(r["uri"].strip())
        except Exception as e:
            msg = f"Could not process {r["uri"]} as a term URI."
            print(msg)
            print(e)
            warn(msg)
            return
        try:
            type = self._process_type(r["type"].strip())
            vg.add((term, RDF.type, type))
        except ValueError as e:
            print(f"Could not process {term}.")
            print(e)
            warn(e)
            return
        if type == OWL.Ontology:
            self._process_owl_row(r, term)
        elif type == RDFS.Class:
            self._process_rdfs_class_row(r, term)
        elif type == RDF.Property:
            self._process_rdfs_property_row(r, term)
        elif type == SKOS.ConceptScheme:
            self._process_scheme_row(r, term)
        elif type == SKOS.Concept:
            self._process_concept_row(r, term)
        else:
            # shouldn't really ave got this far
            msg = f"Unknown term type {type}."
            raise TypeError(msg)
        return

    def _process_type(self, type_str):
        if type_str in types_map.keys():
            return types_map[type_str]
        else:
            msg = f"Unknown term type {type_str}."
            raise ValueError(msg)

    def _process_term(self, cURI):
        try:
            (prefix, name) = cURI.split(":")
        except:
            print(cURI)
            msg = f"{cURI} does not seem to be a curie."
            raise ValueError(msg)
        # first make sure the prefix is known and bound to the vocab graph
        if prefix in self.namespaces:
            ns_uriref = URIRef(self.namespaces[prefix])
            if (prefix, ns_uriref) in self.vocab_rdf.namespaces():
                pass
            else:
                ns = Namespace(self.namespaces[prefix])
                self.vocab_rdf.bind(prefix, ns)
        else:
            msg = f"Prefix {prefix} does not correspond to a known namespace."
            raise ValueError(msg)
        # clean the name for URI use
        clean_name = quote_plus(name.strip())
        # then add the term URI to the graph
        term = URIRef(ns_uriref + clean_name)
        return term

    def _process_owl_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, RDFS.label, Literal(label)))
        if ("comment" in r.keys()) and (r["comment"].strip() != ""):
            comment = r["comment"].strip()
            vg.add((term, RDFS.comment, Literal(comment)))
        if ("usageNote" in r.keys()) and (r["usageNote"].strip() != ""):
            usage = r["usageNote"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        return

    def _process_rdfs_class_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, RDFS.label, Literal(label)))
        if ("comment" in r.keys()) and (r["comment"].strip() != ""):
            comment = r["comment"].strip()
            vg.add((term, RDFS.comment, Literal(comment)))
        if ("usageNote" in r.keys()) and (r["usageNote"].strip() != ""):
            usage = r["usageNote"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        return

    def _process_rdfs_property_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, RDFS.label, Literal(label)))
        if ("comment" in r.keys()) and (r["comment"].strip() != ""):
            comment = r["comment"].strip()
            vg.add((term, RDFS.comment, Literal(comment)))
        if ("usageNote" in r.keys()) and (r["usageNote"].strip() != ""):
            usage = r["usageNote"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        if ("domainIncludes" in r.keys()) and (r["domainIncludes"].strip() != ""):
            domainList = r["domainIncludes"].strip()
            for domain_str in split(splitters, domainList):
                if domain_str.strip() != "":
                    domain = self._process_term(domain_str.strip())
                    vg.add((term, SDO.domainIncludes, domain))
        if ("rangeIncludes" in r.keys()) and ((r["rangeIncludes"].strip() != "")):
            rangeList = r["rangeIncludes"].strip()
            for range_str in split(splitters, rangeList):
                if range_str.strip() != "":
                    range = self._process_term(range_str.strip())
                    vg.add((term, SDO.rangeIncludes, range))
        return

    def _process_scheme_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, DCTERMS.title, Literal(label)))
        if ("definition" in r.keys()) and (r["definition"].strip() != ""):
            definition = r["definition"].strip()
            vg.add((term, DCTERMS.description, Literal(definition)))
        if ("usageNote" in r.keys()) and (r["usageNote"].strip() != ""):
            usage = r["usageNote"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        if (("relatedTerm") in r.keys()) and (r["relatedTerm"].strip() != ""):
            for related in split(splitters, r["relatedTerm"].strip()):
                self._process_related_terms(r["relationship"], related.strip(), term)
        return

    def _process_concept_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, SKOS.prefLabel, Literal(label)))
        if ("definition" in r.keys()) and (r["definition"].strip() != ""):
            definition = r["definition"].strip()
            vg.add((term, SKOS.definition, Literal(definition)))
        if ("notation" in r.keys()) and (r["notation"].strip() != ""):
            notation = r["notation"].strip()
            vg.add((term, SKOS.notation, Literal(notation)))
        if (("relatedTerm") in r.keys()) and (r["relatedTerm"].strip() != ""):
            for related in split(splitters, r["relatedTerm"].strip()):
                self._process_related_terms(r["relationship"], related.strip(), term)
        return

    def _process_related_terms(self, relationship: str, rel_term: str, termRef: URIRef):
        vg = self.vocab_rdf
        try:
            rel_term = rel_term.strip()
            rels = relationship.strip()
        except:
            msg = f"Must have stringvalues for both term and relationship. Have term = {rel_term} and relationsip = {relationship}."
            raise ValueError(msg)
        for rel in split(splitters, rels):
            r = toLowerCamelCase(rel)
            if r in relationships_map.keys():
                rel_termRef = self._process_term(rel_term)
                relRef = relationships_map[r]
                vg.add((termRef, relRef, rel_termRef))
            else:
                msg = f"Cannot process relationship {termRef}, {r}, {rel_term}."
                print(msg)
                warn(msg)
