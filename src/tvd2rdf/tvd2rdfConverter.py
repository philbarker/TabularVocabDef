from csv import DictReader
from rdflib import Graph, URIRef, Literal, Namespace
from rdflib import RDF, RDFS, OWL, SDO, SKOS, DCTERMS
from re import split
from warnings import warn
from otsrdflib import OrderedTurtleSerializer
from urllib.parse import quote_plus
from ._version import __version__ as version
from ._utils import toLowerCamelCase, load_config, convert_namespace, str2URIRef


class tvd2rdfConverter:
    """Class to read a csv file with certain column headings defining an RDF vocabulary, convert it to an RDF graph and outputas RDF file."""

    def __init__(self):
        self.vocab_rdf = Graph()
        config = load_config()
        self._init_namespaces(config["namespaces"])
        self._init_types_map(config["types map"])
        self._init_relationships_map(config["relationships map"])
        self.splitters = config["splitters"]
        self._init_fields_map(config["fields map"])

    def _init_namespaces(self, namespaces: dict):
        self.namespaces = dict()
        for ns in namespaces.keys():
            self.add_namespace(ns, namespaces[ns])
        return

    def _init_types_map(self, types_map):
        self.types_map = dict()
        for t in types_map.keys():
            self.add_type(t, types_map[t])

    def _init_relationships_map(self, relationships_map):
        self.relationships_map = dict()
        for r in relationships_map.keys():
            self.add_relationship(r, relationships_map[r])

    def _init_fields_map(self, fields_map):
        self.fields_map = dict()
        self.known_fields = list()
        for d in fields_map.keys():
            for f in fields_map[d].keys():
                self.add_field(d, f, fields_map[d][f])

    def _init_serialization_order(self, order):
        self.serialization_order = list()
        for c in order:
            classURI = str2URIRef(c)
            self.serialization_order.append(c)

    def add_namespace(self, prefix, uri):
        ns = convert_namespace(prefix, uri)
        self.namespaces.update(ns)
        return

    def add_type(self, t, uri_str):
        """Add a mapping of a type to a URIRef to the types map attribute"""
        uri = str2URIRef(self.namespaces, uri_str)
        self.types_map.update({t: uri})
        return

    def add_relationship(self, r, uri_str):
        uri = str2URIRef(self.namespaces, uri_str)
        self.relationships_map.update({r: uri})
        return

    def add_field(self, domain, field, uri_str):
        uri = str2URIRef(self.namespaces, uri_str)
        d = toLowerCamelCase(domain)
        f = toLowerCamelCase(field)
        if d in self.fields_map.keys():
            pass
        else:
            v = dict()
            self.fields_map.update({d: v})
        self.fields_map[d].update({f: uri})
        if f not in self.known_fields:
            self.known_fields.append(f)
        else:
            pass
        return

    def read_csv(self, fname):
        with open(fname, "r") as csv_file:
            csv_reader = DictReader(csv_file)
            self.check_keys(csv_reader.fieldnames)
            for row in csv_reader:
                try:
                    self.convert_row(row)
                except ValueError as e:
                    msg = f"Cannot convert row {row}."
                    print(e)
                    warn(msg)
        return

    def read_namespaces(self, fname):
        """Load namespaces from a (csv) file."""
        with open(fname, "r") as csv_file:
            csvReader = DictReader(csv_file)
            for row in csvReader:
                if row["prefix"] and row["URI"]:
                    self.add_namespace(row["prefix"], row["URI"])
                elif row["URI"]:
                    self.add_namespace("", row["URI"])
                else:  # pass rows with missing data
                    pass

    def write_out(self, fn: str = "", fmt: str = ""):
        """Write the vocabulary terms definition file."""
        vg = self.vocab_rdf  # vocab graph
        if fmt == "":
            fmt = "turtle"
        if fmt in ["turtle", "n3", "nquads", "longturtle", "trig", "nt"]:
            aknow_str = f"# RDF generated by TVD2RDF Converter v{version}."
        elif fmt in ["xml", "pretty-xml", "trix"]:
            aknow_str = f"<!--RDF generated by TVD2RDF Converter v{version}.-->"
        else:
            aknow_str = ""
        if fn:  # output to file
            try:
                f = open(fn, "w")
            except Exception as e:
                print(f"Could not open file {fn} for writing.")
                raise e
            f.write(aknow_str)
            f.write("\n")
            f.close()
            if fmt == "turtle":  # Ordered serializaion...
                serializer = OrderedTurtleSerializer(vg)
                serializer.class_order = self.serialization_order
                with open(fn, "ab") as f:
                    serializer.serialize(f)
            else:
                with open(fn, "a") as f:
                    f.write(vg.serialize(format=fmt))
        else:  # output to terminal
            print("\n", aknow_str)
            print(vg.serialize(format=fmt))
            print("\n\n")

    def check_keys(self, fields):
        lower_fields = [f.lower() for f in fields]
        if ("uri" in lower_fields) and ("type" in lower_fields):
            pass
        else:
            msg = f"Must have columns for Type and URI in the input csv."
            raise ValueError(msg)
            return False
        for f in fields:
            field = toLowerCamelCase(f)
            if field in self.known_fields:
                pass
            else:
                msg = f"Cannot convert column {f} to RDF term."
                print(field)
                warn(msg, stacklevel=2)
                return False
        return True

    def convert_row(self, row: dict):
        vg = self.vocab_rdf
        r = dict()
        for key, val in row.items():
            new_key = toLowerCamelCase(key)
            r[new_key] = val
        try:
            term = self._process_term(r["uri"].strip())
        except Exception as e:
            msg = f"Could not process {r["uri"]} as a term URI."
            print(e)
            warn(msg)
            return
        try:
            type = self._process_type(r["type"].strip())
            vg.add((term, RDF.type, type))
        except ValueError as e:
            print(e)
            msg = f"Could not process {term}."
            warn(msg)
            return
        if type == OWL.Ontology:
            self._process_owl_row(r, term)
        elif type == RDFS.Class:
            self._process_rdfs_class_row(r, term)
        elif type == RDF.Property:
            self._process_rdfs_property_row(r, term)
        elif type == SKOS.ConceptScheme:
            self._process_scheme_row(r, term)
        elif type == SKOS.Concept:
            self._process_concept_row(r, term)
        else:
            # shouldn't really ave got this far
            msg = f"Unknown term type {type}."
            raise TypeError(msg)
        return

    def _process_type(self, type_str):
        if type_str in self.types_map.keys():
            return self.types_map[type_str]
        else:
            msg = f"Unknown term type {type_str}."
            raise ValueError(msg)

    def _process_term(self, cURI):
        try:
            (prefix, name) = cURI.split(":")
        except:
            print(cURI)
            msg = f"{cURI} does not seem to be a curie."
            raise ValueError(msg)
        # first make sure the prefix is known and bound to the vocab graph
        if prefix in self.namespaces:
            ns_uriref = URIRef(self.namespaces[prefix])
            if (prefix, ns_uriref) in self.vocab_rdf.namespaces():
                pass
            else:
                ns = Namespace(self.namespaces[prefix])
                self.vocab_rdf.bind(prefix, ns)
        else:
            msg = f"Prefix {prefix} does not correspond to a known namespace."
            raise ValueError(msg)
        # clean the name for URI use
        clean_name = quote_plus(name.strip())
        # then add the term URI to the graph
        term = URIRef(ns_uriref + clean_name)
        return term

    def _process_owl_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, RDFS.label, Literal(label)))
        if ("comment" in r.keys()) and (r["comment"].strip() != ""):
            comment = r["comment"].strip()
            vg.add((term, RDFS.comment, Literal(comment)))
        if ("usageNote" in r.keys()) and (r["usageNote"].strip() != ""):
            usage = r["usageNote"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        return

    def _process_rdfs_class_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, RDFS.label, Literal(label)))
        if ("comment" in r.keys()) and (r["comment"].strip() != ""):
            comment = r["comment"].strip()
            vg.add((term, RDFS.comment, Literal(comment)))
        if ("usageNote" in r.keys()) and (r["usageNote"].strip() != ""):
            usage = r["usageNote"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        return

    def _process_rdfs_property_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        splitters = self.splitters
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, RDFS.label, Literal(label)))
        if ("comment" in r.keys()) and (r["comment"].strip() != ""):
            comment = r["comment"].strip()
            vg.add((term, RDFS.comment, Literal(comment)))
        if ("usageNote" in r.keys()) and (r["usageNote"].strip() != ""):
            usage = r["usageNote"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        if ("domainIncludes" in r.keys()) and (r["domainIncludes"].strip() != ""):
            domainList = r["domainIncludes"].strip()
            for domain_str in split(splitters, domainList):
                if domain_str.strip() != "":
                    domain = self._process_term(domain_str.strip())
                    vg.add((term, SDO.domainIncludes, domain))
        if ("rangeIncludes" in r.keys()) and ((r["rangeIncludes"].strip() != "")):
            rangeList = r["rangeIncludes"].strip()
            for range_str in split(splitters, rangeList):
                if range_str.strip() != "":
                    range = self._process_term(range_str.strip())
                    vg.add((term, SDO.rangeIncludes, range))
        return

    def _process_scheme_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        splitters = self.splitters
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, DCTERMS.title, Literal(label)))
        if ("definition" in r.keys()) and (r["definition"].strip() != ""):
            definition = r["definition"].strip()
            vg.add((term, DCTERMS.description, Literal(definition)))
        if ("usageNote" in r.keys()) and (r["usageNote"].strip() != ""):
            usage = r["usageNote"].strip()
            vg.add((term, SKOS.note, Literal(usage)))
        if (("relatedTerm") in r.keys()) and (r["relatedTerm"].strip() != ""):
            for related in split(splitters, r["relatedTerm"].strip()):
                self._process_related_terms(r["relationship"], related.strip(), term)
        return

    def _process_concept_row(self, r: dict, term: URIRef):
        vg = self.vocab_rdf
        splitters = self.splitters
        if ("label" in r.keys()) and (r["label"].strip() != ""):
            label = r["label"].strip()
            vg.add((term, SKOS.prefLabel, Literal(label)))
        if ("definition" in r.keys()) and (r["definition"].strip() != ""):
            definition = r["definition"].strip()
            vg.add((term, SKOS.definition, Literal(definition)))
        if ("notation" in r.keys()) and (r["notation"].strip() != ""):
            notation = r["notation"].strip()
            vg.add((term, SKOS.notation, Literal(notation)))
        if (("relatedTerm") in r.keys()) and (r["relatedTerm"].strip() != ""):
            for related in split(splitters, r["relatedTerm"].strip()):
                self._process_related_terms(r["relationship"], related.strip(), term)
        return

    def _process_related_terms(self, relationship: str, rel_term: str, termRef: URIRef):
        vg = self.vocab_rdf
        splitters = self.splitters
        try:
            rel_term = rel_term.strip()
            rels = relationship.strip()
        except:
            msg = f"Must have stringvalues for both term and relationship. Have term = {rel_term} and relationsip = {relationship}."
            raise ValueError(msg)
        for rel in split(splitters, rels):
            r = toLowerCamelCase(rel)
            if r in self.relationships_map.keys():
                rel_termRef = self._process_term(rel_term)
                relRef = self.relationships_map[r]
                vg.add((termRef, relRef, rel_termRef))
            else:
                msg = f"Cannot process relationship {termRef}, {r}, {rel_term}."
                warn(msg)
